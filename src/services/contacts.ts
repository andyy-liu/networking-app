import { supabase } from "@/lib/client";
import type { Contact, ContactTag } from "@/lib/types";

// async allows for the use of await inside the function and lets the function return a Promise
// await pauses the execution of the function until the Promise is resolved
// Promise represents the eventual completion (or failure) of an asynchronous operation and its resulting value
export async function fetchContacts(userId: string): Promise<Contact[]> {
  // this const returns the data and error from the supabase query
  const { data, error } = await supabase
    .from("contacts") // specify the table name to query
    .select("*") // select all columns in the table
    .eq("user_id", userId); // filter the results to only include contacts for the given userId
  if (error) throw error;
  return (
    // turn the raw data into a structured Contact object
    data?.map(item => ({
      id: item.id,
      name: item.name,
      email: item.email,
      role: item.role || "", // default to empty string if role is null
      company: item.company || "",
      tags: item.tags as ContactTag[], // cast the tags to ContactTag[]
      dateOfContact: item.dateofcontact,
      status: item.status as Contact["status"],
      todos: [] // initialize todos as an empty array
    })) ?? [] // if data is null or undefined, return an empty array
  );
}


export async function createContact(
  userId: string,
  // Omit removes the id property from the Contact type
  // this is useful when creating a new contact because the id will be generated by the database
  newData: Omit<Contact, "id"> 
): Promise<Contact> {
  const { data, error } = await supabase
    .from("contacts")
    .insert({
      user_id: userId,
      name: newData.name,
      email: newData.email,
      role: newData.role || null,
      company: newData.company || null,
      tags: newData.tags,
      dateofcontact: newData.dateOfContact,
      status: newData.status
    })
    .select()
    .single(); // select the newly created contact and return it as a single object
  if (error) throw error;
  return {
    id: data.id,
    name: data.name,
    email: data.email,
    role: data.role || "",
    company: data.company || "",
    tags: data.tags as ContactTag[],
    dateOfContact: data.dateofcontact,
    status: data.status as Contact["status"],
    todos: []
  };
}


export async function updateContact(
  userId: string,
  updated: Contact
): Promise<void> { // void indicates that the function does not return a value but still does something that takes time
  const { error } = await supabase
    .from("contacts")
    .update({
      name: updated.name,
      email: updated.email,
      role: updated.role || null,
      company: updated.company || null,
      tags: updated.tags,
      dateofcontact: updated.dateOfContact,
      status: updated.status,
      updated_at: new Date().toISOString() // set the updated_at field to the current date and time
    })
    .eq("id", updated.id) 
    .eq("user_id", userId);
  if (error) throw error;
}


export async function deleteContacts(
  userId: string,
  ids: string[]
): Promise<void> {
  const { error } = await supabase
    .from("contacts")
    .delete()
    .in("id", ids)
    .eq("user_id", userId);
  if (error) throw error;
}
